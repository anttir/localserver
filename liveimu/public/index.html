<html>

<head>
    <title>Live telemetry</title>
    <!-- The following meta line optimizes the site for mobile devices. It sets the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="stylesheet" type="text/css" href="main.css" />
    <style>
        body {
            font: 10px sans-serif;
        }

        .graph .axis {
            stroke-width: 1;
        }

            .graph .axis .tick line {
                stroke: black;
            }

            .graph .axis .tick text {
                fill: black;
                font-size: 0.7em;
            }

            .graph .axis .domain {
                fill: none;
                stroke: black;
            }

        .graph .group {
            fill: none;
            stroke: black;
            stroke-width: 1.5;
        }

        #WebGLCanvas {
            width: 200px;
            height: 200px;
        }

        #throttleSteeringGraph .axis path,
        #throttleSteeringGraph .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        #throttleSteeringGraph .dot {
            fill: none;
        }

        #throttleSteeringGraph .grid path {
            fill: none;
            stroke: #ccc;
            shape-rendering: crispEdges;
        }

        .button {
            border: 1px solid #eee;
            padding: 8px;
            /*display: inline;*/
        }
        /*.dot {
            stroke: #000;
        }*/
    </style>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.js"></script>
    <script src="threejs_renderer.js"></script>
</head>

<body>
    <div id="WebGLCanvas"></div>
    <svg id="throttleSteeringGraph"></svg><br />
    <div class="button" id="btnCalibrateTransmitter">Calibrate</div><span id="calibrationResults"></span><br />
    <div class="button" id="btnCenterTransmitter">Center</div><br />
    <div class="button" id="btnResetTransmitterData">Reset</div><br />
    <div class="button" id="pauseChart">pause</div>
    <div id="lineGraph" class="graph"></div>
    <div id="rotationGraph"></div>
    <div class="button" id="pauseTable">pause</div>
    <div id="tableDiv">
        <table id="dataTable">
            <thead>
                <tr>
                    <th class="dataCell">Accel X</th>
                    <th class="dataCell">Accel Y</th>
                    <th class="dataCell">Accel Z</th>
                    <th class="dataCell">Rotation X</th>
                    <th class="dataCell">Rotation Y</th>
                    <th class="dataCell">Rotation Z</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <script>

        function sensor() {
            this.AccelerationX = 0;
            this.AccelerationY = 0;
            this.AccelerationZ = 0;
            this.RotationX = 0;
            this.RotationY = 0;
            this.RotationZ = 0;
            this.Pitch = function () {
            };
        };

        var groupNames = ['Timestamp', 'AccelX', 'AccelY', 'AccelZ', 'RotationX', 'RotationY', 'RotationZ', 'Steering', 'Throttle'];
        var TIMESTAMP = 'Timestamp';

        var c10 = d3.scale.category10();
        var valueRange = 20000; //32768;
        var samples = 500;
        var rowsToKeep = 10;
        var timeStamps = Array(samples);
        var time = new Date();
        timeStamps.fill(time.getTime());

        var pauseTable = false;
        var pauseChart = false;

        var width = 500,
            height = 200;

        var groups = {};
        for (i = 0; i < groupNames.length ; i++) {
            groups[groupNames[i]] = {
                value: 0,
                color: c10(i),
                data: Array(samples).fill([time, 0])
            };
        }

        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }

        $(function () {

            $("#pauseTable,#pauseChart").click(function (e) {
                window[this.id] = !window[this.id];
                if (window[this.id]) {
                    $(this).text("resume")
                } else {
                    $(this).text("pause")
                }
            })

            if (!!window.EventSource) {
                // Good example on using SSE
                // http://www.html5rocks.com/en/tutorials/eventsource/basics/

                var source = new EventSource('data');
                source.addEventListener('message', function (e) {
                    // Split the comma-separated list of values into an array of values
                    var data = e.data.split(",").map(function (d) { return Number(d) || null });
                    data.unshift(Date.now()); // Lis‰t‰‰n alkuun vastaanottohetken aikaleima (ei tietty ole aivan tarkka, mutta...)
                    tick(data);
                }, false);
            }
            else {
                console.log('sse not supported');
            }

            // kirjoitetaan sarakeotsikot
            $("#dataTable thead tr").html(groupNames.map(function (d) { return "<th>" + d + "</th>"; }).join(""))

        });



        var x = d3.time.scale()
            .domain([timeStamps[0], timeStamps[timeStamps.length - 1]])
            //.domain([time, new Date(time.getTime() + 2 * 60000)]) // add 5 minutes
            .range([0, width]);

        var y = d3.scale.linear()
            .domain([-valueRange, valueRange])
            .range([height, 0])

        var line = d3.svg.line()
            .interpolate('basis')
            .defined(function (d) { return !isNaN(d[1]); })
            .x(function (d, i) {
                return x(d[0]);
            })
            .y(function (d) {
                return y(d[1]);
            })

        var svg = d3.select('#lineGraph').append('svg')
            .attr('class', 'chart')
            .attr('width', width)
            .attr('height', height + 50)

        var axis = svg.append('g')
            .attr('class', 'x axis')
            .attr('transform', 'translate(0,' + height + ')')
            .call(x.axis = d3.svg.axis().scale(x).orient('bottom'))

        var paths = svg.append('g')

        for (var name in groups) {
            var group = groups[name]
            group.path = paths.append('path')
                .data([group.data])
                .attr('class', name + ' group')
                .style('stroke', group.color)
        }
        /** @description Updates the screen with new data
         * @param {data} Array of integer values
         * @return {null} Nothing
         */
        function tick(data) {
            if (data && data.length == groupNames.length) {
                if (!pauseTable) {
                    // p‰ivitet‰‰n taulukko
                    var rowCount = $('#dataTable > tbody > tr').length;
                    if ((rowCount + 1) >= rowsToKeep) {
                        // After adding rows, there will be too many, remove last
                        $('#dataTable > tbody > tr:last').remove();
                    }
                    // Prepare a row
                    var html = '<tr>';
                    for (var ii = 0; ii < data.length; ii++) {
                        html += '<td>' + data[ii] + '</td>';
                    }
                    html += '</tr>';
                    // Insert at the beginning
                    $(html).prependTo("#dataTable > tbody");
                }

                // p‰ivitet‰‰n kuvaaja
                if (!pauseChart) {

                    // update Timestamps
                    var time = parseInt(data[0]);
                    timeStamps.push(time);
                    timeStamps.shift();

                    var currData = {};

                    // Add new values
                    for (i = 1; i < groupNames.length; i++) {
                        var name = groupNames[i];
                        currData[name] = data[i];
                        var group = groups[name];
                        group.data.push([time, data[i]]);
                        group.path.attr('d', line);
                    }

                    // Shift axis domain and update axis
                    x.domain([timeStamps[0], time]);
                    axis.call(x.axis);

                    // Remove oldest data point from each group
                    for (var name in groups) {
                        var group = groups[name]
                        group.data.shift()
                    }


                    // lasketaan asento

                    var R = Math.sqrt(Math.pow(currData.AccelX, 2) + Math.pow(currData.AccelY, 2) + Math.pow(currData.AccelZ, 2));
                    var Arx = Math.acos(currData.AccelX / R) * 180 / Math.PI;
                    var Ary = Math.acos(currData.AccelY / R) * 180 / Math.PI;
                    var Arz = Math.acos(currData.AccelZ / R) * 180 / Math.PI;

                    $("#rotationGraph").text(
                        "X" + Math.round(Arx) + " | " +
                        "Y" + Math.round(Ary) + " | " +
                        "Z" + Math.round(Arz)
                    );
                    rotateCube(Arx, Ary, Arz);
                }

                // p‰ivitet‰‰n Scatterplot (kaasu ja ohjaus)

                updatePlotter([[data[groupNames.indexOf("Steering")], data[groupNames.indexOf("Throttle")]]]);
            }

        }
    </script>

    <script id="trottleSteeringGraphJS">
        var config = {
            receiver: {
                minX: 1109,
                maxX: 1837,
                minY: 981,
                maxY: 1841,
                centerX: 1400,
                centerY: 1721,
                //minX: 1000,
                //maxX: 2000,
                //minY: 1000,
                //maxY: 2000,
                //centerX: 1500,
                //centerY: 1500,
            }
        }
        var isCalibrating = "";
        var calibratingEnds = 0;
        var centerData = [];
        var calibrateTransmitter = function () {
            config.receiver.minX = 9999;
            config.receiver.minY = 9999;
            config.receiver.maxX = 0;
            config.receiver.maxY = 0;
            isCalibrating = "minMax";
            calibratingEnds = new Date();
            calibratingEnds.setSeconds(calibratingEnds.getSeconds() + 5);
        }
        var centerTransmitter = function () {
            config.receiver.centerX = 1500;
            config.receiver.centerY = 1500;
            isCalibrating = "center";
            centerData = [];
            calibratingEnds = new Date();
            calibratingEnds.setSeconds(calibratingEnds.getSeconds() + 2);
        }

        function TSGraph() {
            var gridSize = 9;
            this.graph = {};
            this.grid = {};
            this.margin = { top: 20, right: 20, bottom: 30, left: 40 };
            this.width = 300 - this.margin.left - this.margin.right;
            this.height = 300 - this.margin.top - this.margin.bottom;
            this.x = d3.scale.linear()
                .range([0, this.width])
                .domain([0, 100]);
            this.y = d3.scale.linear()
                .range([this.height, 0])
                .domain([0, 100]);
            var getCoords = function (width, height) {
                var cellSizeX = width / gridSize;
                var cellSizeY = height / gridSize;
                var results = [];
                for (var i = 0; i < gridSize; i++) {
                    for (var j = 0; j < gridSize; j++) {
                        results.push(
                            {
                                coords: [{ x0: i * cellSizeX, y0: j * cellSizeY, x1: (i + 1) * cellSizeX, y1: j * cellSizeY },
                                        { x0: i * cellSizeX, y0: (j + 1) * cellSizeY, x1: (i + 1) * cellSizeX, y1: (j + 1) * cellSizeY }],
                                count: 1, //100 / (gridSize * gridSize)
                                name : "i=" + i + ":j=" +j
                            }
                        );
                    }
                }
                return results;
            };
            this.gridData = getCoords(this.width, this.height);
            this.resetTransmitterData = function () { this.gridData = getCoords(this.width, this.height); };
            this.areaFunc = d3.svg.area()
                .interpolate('step')
                .x0(function (d) { return d.x0; })
                .x1(function (d) { return d.x1; })
                .y0(function (d) { return d.y0; })
                .y1(function (d) { return d.y1; });
            this.colorFunc = function (x) {
                return d3.hsl(120, 1, 1 - x);
            };
            this.drawGrid = function (data) {
                var tickTotal = data.map(function (d) { return d.count; }).reduce(function (a, b) { return a + b; }, 0);
                TSG.graph.selectAll('.grid > *').remove();
                this.grid = TSG.graph.select('.grid').selectAll('path')
                    .data(data)
                    .enter()
                    .append('path')
                        .attr("class", "enter")
                        .attr("class", "cell")
                        .attr('d', function (d) {
                            return TSG.areaFunc(d.coords);
                        })
                        .style('fill', function (d) {
                            return TSG.colorFunc(d.count / tickTotal);
                        })
                    .append('text')
                        .style("text-anchor", "middle")
                        .text(function (d) { return d.name; });

            }
            this.setNewGridData = function (data) {
                if (data[0] >= 0 && data[1] >= 0 && data[0] <= 100 && data[1] <= 100) {
                    var cell = [
                                    Math.round(data[0] / 100 * (gridSize - 1)),
                                    gridSize - 1 - Math.round(data[1] / 100 * (gridSize - 1))
                    ];
                    (this.gridData[(cell[0] * gridSize) + cell[1] ].count)++; // lis‰t‰‰n t‰h‰n ruutuun yksi
                } else {
                    console.log('invalid data' + JSON.stringify(data));
                }
                this.drawGrid(this.gridData);
            }
            this.getCalibratedData = function (data) {
                // skaalataan arvo v‰lille 0-100 ja niin ett‰ keskusta on keskell‰
                if (data[0] < config.receiver.centerX) {
                    data[0] = (data[0] - config.receiver.minX) / (config.receiver.centerX - config.receiver.minX) * 50;
                } else {
                    data[0] = ((data[0] - config.receiver.centerX) / (config.receiver.maxX - config.receiver.centerX) * 50) + 50;
                }
                if (data[1] < config.receiver.centerX) {
                    data[1] = (data[1] - config.receiver.minY) / (config.receiver.centerY - config.receiver.minY) * 50;
                } else {
                    data[1] = ((data[1] - config.receiver.centerY) / (config.receiver.maxY - config.receiver.centerY) * 50) + 50;
                }
                return data;
            }
        }
        var TSG = new TSGraph();
        var resetTransmitterData = function () { TSG.resetTransmitterData(); }

        $(function () {
            var color = d3.scale.category10();

            TSG.xAxis = d3.svg.axis()
                .scale(TSG.x)
                .orient("bottom");

            TSG.yAxis = d3.svg.axis()
                .scale(TSG.y)
                .orient("left");

            TSG.graph = d3.select("#throttleSteeringGraph")
                .attr("width", TSG.width + TSG.margin.left + TSG.margin.right)
                .attr("height", TSG.height + TSG.margin.top + TSG.margin.bottom)
              .append("g")
                .attr("transform", "translate(" + TSG.margin.left + "," + TSG.margin.top + ")");

            TSG.graph.append("g").attr("class", "grid");
            TSG.drawGrid(TSG.gridData);

            TSG.graph.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + TSG.height + ")")
                .call(TSG.xAxis)
              .append("text")
                .attr("class", "label")
                .attr("x", TSG.width)
                .attr("y", -6)
                .style("text-anchor", "end")
                .text("Steering");

            TSG.graph.append("g")
                .attr("class", "y axis")
                .call(TSG.yAxis)
              .append("text")
                .attr("class", "label")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Throttle")
            TSG.graph.append("g").attr("class", "dots");

            $("#btnCalibrateTransmitter").click(function () { calibrateTransmitter(); });
            $("#btnCenterTransmitter").click(function () { centerTransmitter(); });
            $("#btnResetTransmitterData").click(function () { resetTransmitterData(); });

        });

        function updatePlotter(data) {
            if (isCalibrating == "minMax") {
                var now = new Date();
                if (now < calibratingEnds) {
                    $("#btnCalibrateTransmitter").text((Math.round((calibratingEnds - now) / 100) / 10) + "...");
                    var show = "";
                    if (data[0][0] < config.receiver.minX) { config.receiver.minX = data[0][0]; show = "min"; }
                    if (data[0][0] > config.receiver.maxX) { config.receiver.maxX = data[0][0]; show = "max"; }
                    if (data[0][1] < config.receiver.minY) { config.receiver.minY = data[0][1]; show = "min"; }
                    if (data[0][1] > config.receiver.maxY) { config.receiver.maxY = data[0][1]; show = "max"; }
                    switch (show) {
                        case "min":
                            data = [[config.receiver.minX, config.receiver.minY]]; // n‰ytet‰‰n maksimit
                            break;
                        case "max":
                            data = [[config.receiver.maxX, config.receiver.maxY]]; // n‰ytet‰‰n maksimit
                            break;
                        default:
                            data = [[(config.receiver.maxX + config.receiver.minX) / 2, (config.receiver.minY + config.receiver.maxY) / 2]]; // n‰ytet‰‰n keskikohta
                    }
                    TSG.x.domain([config.receiver.minX, config.receiver.maxX]);
                    TSG.y.domain([config.receiver.minY, config.receiver.maxY]);
                    $("#calibrationResults").text(JSON.stringify(config.receiver));
                    TSG.graph.selectAll(".x.axis").call(TSG.xAxis);
                    TSG.graph.selectAll(".y.axis").call(TSG.yAxis);
                } else {
                    isCalibrating = "";
                    calibratingEnds = 0;
                    // kuvaaja takaisin normalisoiduksi
                    TSG.x.domain([0, 100]);
                    TSG.y.domain([0, 100]);
                    TSG.graph.selectAll(".x.axis").call(TSG.xAxis);
                    TSG.graph.selectAll(".y.axis").call(TSG.yAxis);
                    $("#btnCalibrateTransmitter").text("Calibrate");
                    TSG.resetTransmitterData();
                }
            }
            if (isCalibrating == "center") {
                var now = new Date();
                if (now < calibratingEnds) {
                    $("#btnCenterTransmitter").text((Math.round((calibratingEnds - now) / 100) / 10) + "...");
                    centerData.push([data[0][0], data[0][1]]);
                } else {
                    isCalibrating = "";
                    calibratingEnds = 0;
                    config.receiver.centerX = centerData.map(function (x) { return x[0]; }).reduce(function (a, b) { return a + b; }) / centerData.length;
                    config.receiver.centerY = centerData.map(function (x) { return x[1]; }).reduce(function (a, b) { return a + b; }) / centerData.length;
                    $("#btnCenterTransmitter").text("Center" + config.receiver.centerX + "|" + config.receiver.centerY);
                    TSG.resetTransmitterData();
                }
            }
            // map values to 0 - +100 on both axis
            if (isCalibrating != "minMax") {
                data[0] = TSG.getCalibratedData(data[0]);
                TSG.setNewGridData(data[0]);
            }

            // ---------------------

            // JOIN new data with old elements.
            var dataset = TSG.graph.select('.dots').selectAll(".dot")
                .data(data, function (d) { return d + Math.random() * 0.0001; }); // v‰h‰n hajontaa, jotta jokainen piste piirret‰‰n

            // EXIT old elements not present in new data.
            //dataset.exit()
            //    .attr("class", "exit")

            // UPDATE old elements present in new data.
            //dataset.attr("class", "update")
            //    .attr("y", 0)
            //    .style("fill-opacity", 1)

            // ENTER new elements present in new data.
            dataset.enter().append("circle")
                .attr("class", "enter")
                .attr("class", "dot")
                .attr("r", 3.5)
                .attr("cx", function (d) { return TSG.x(d[0]); })
                .attr("cy", function (d) { return TSG.y(d[1]); })
                .style("stroke", "red")
                .style("stroke-opacity", 1)
                .transition()
                .duration(3000)            // n‰kyy 10 s
                .attr("r", 0)               // pienenee
                .style("stroke-opacity", 0)   // vaalenee
                .remove();                    // poistetaan kokonaan
        };
        //function createTestData(numValues) {
        //    dataset = [];  // Initialize empty array
        //    for (var i = 0; i < numValues; i++) {
        //        var x = config.receiver.minX + Math.floor(Math.random() * config.receiver.maxX);  // Random int for x
        //        var y = config.receiver.miny + Math.floor(Math.random() * config.receiver.maxY);  // Random int for y
        //        dataset.push([x, y]);  // Add new numbers to array
        //    }
        //    return dataset;
        //}

    </script>

</body>

</html>